git branch 查看本地所有分支
git branch <file> 创建分支
/**************************************************/
git checkout <file> 切换分支
git checkout -b <file> 创建并切换分支
git checkout -d <file> 删除分支
git checkout --<file> 将在工作区的修改全部撤销
/**************************************************/
git reset HEAD <file> 把暂存区的修改回退到工作区(HEAD表示最新的版本)
git reset --hard HEAD 回退到最新版本,等于删除工作区和暂存区的内容
git reset --hard HEAD^ 回退到上一次commit
git reset --hard e348162 回退到指定commit id版本(id可以不写完整)
注：HEAD最新版本, HEAD^ HEAD~1上一版本. 以此类推.
   --soft: 缓存区和工作目录都不会被改变
   --mixed: 默认选项。缓存区和你指定的提交同步, 但工作目录不受影响
   --hard: 缓存区和工作目录都同步到你指定的提交
/**************************************************/
git revert HEAD~2同git reset --hard HEAD~2类似, 区别在于前者通过提交新的commit回到指定版本,后者为指针直接回退
/**************************************************/
git merge <branch> 合并分支
/**************************************************/
git rebase <branch>同git merge <branch>类似,
它的原理是回到两个分支最近的共同祖先, 根据当前分支(也就是要进行变基的分支)后续的历次提交对象, 
生成一系列文件补丁, 然后以基底分支最后一个提交对象为新的出发点, 逐个应用之前准备好的补丁文件, 
最后会生成一个新的合并提交对象, 从而改写提交历史, 使它成为直接下游
注: 合并结果中最后一次提交所指向的快照, 无论是通过变基, 还是三方合并, 都会得到相同的快照内容,
只不过提交历史不同罢了. 变基是按照每行的修改次序重演一遍修改, 而合并是把最终结果合在一起
/**************************************************/
git stash 缓存工作区
git stash list 查看缓存列表
git stash apply 取出最近一次缓存
git stash apply stash@{n} 取出指定缓存
git stash apply --index
git stash drop 删除最近一次缓存
git stash drop stash@{n} 删除指定缓存
git stash pop 取出最近一次缓存并在缓存列表中删除该缓存
git stash show -p stash@{0} | git apply -R
git stash show -p | git apply -R
/**************************************************/
